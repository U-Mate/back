<!DOCTYPE html>
<html>
  <head>
    <title>ğŸ¤ UMate AI - ìŒì„± + í…ìŠ¤íŠ¸ ì±„íŒ…</title>
    <meta charset="UTF-8" />
    <style>
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        max-width: 1100px;
        margin: 0 auto;
        padding: 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
      }
      .container {
        background: white;
        border-radius: 20px;
        box-shadow: 0 25px 70px rgba(0, 0, 0, 0.15);
        overflow: hidden;
      }
      .header {
        background: linear-gradient(135deg, #ff6b6b, #ee5a24);
        color: white;
        padding: 25px;
        text-align: center;
      }
      .header h1 {
        margin: 0;
        font-size: 28px;
        font-weight: bold;
      }
      .header p {
        margin: 15px 0 0 0;
        opacity: 0.9;
        font-size: 16px;
      }
      .features {
        background: rgba(255, 255, 255, 0.1);
        padding: 10px;
        margin-top: 15px;
        border-radius: 10px;
        font-size: 12px;
      }
      #status {
        padding: 18px;
        text-align: center;
        font-weight: bold;
        transition: all 0.3s ease;
        font-size: 16px;
      }
      .status-connecting {
        background: #fff3cd;
        color: #856404;
      }
      .status-connected {
        background: #d4edda;
        color: #155724;
      }
      .status-error {
        background: #f8d7da;
        color: #721c24;
      }
      .status-recording {
        background: #cce5ff;
        color: #004085;
        animation: pulse 1s infinite;
      }

      .main-content {
        display: flex;
        height: 600px;
      }

      #chatContainer {
        flex: 1;
        overflow-y: auto;
        padding: 25px;
        background: #f8f9fa;
      }

      .voice-panel {
        width: 300px;
        background: #f1f3f4;
        border-left: 1px solid #e9ecef;
        padding: 25px;
        display: flex;
        flex-direction: column;
      }

      .voice-controls {
        background: white;
        padding: 20px;
        border-radius: 15px;
        margin-bottom: 20px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }

      .voice-controls h3 {
        margin: 0 0 15px 0;
        color: #333;
        font-size: 18px;
      }

      #recordButton {
        width: 100%;
        padding: 15px;
        font-size: 16px;
        font-weight: bold;
        border: none;
        border-radius: 25px;
        cursor: pointer;
        transition: all 0.3s ease;
        margin-bottom: 15px;
      }

      .record-idle {
        background: linear-gradient(135deg, #28a745, #20c997);
        color: white;
      }

      .record-active {
        background: linear-gradient(135deg, #dc3545, #fd7e14);
        color: white;
        animation: pulse 1s infinite;
      }

      .record-processing {
        background: #6c757d;
        color: white;
        cursor: not-allowed;
      }

      .voice-selector {
        margin-top: 15px;
      }

      .voice-selector label {
        display: block;
        margin-bottom: 5px;
        font-weight: 500;
        color: #555;
      }

      .voice-selector select {
        width: 100%;
        padding: 8px 12px;
        border: 1px solid #ddd;
        border-radius: 8px;
        background: white;
      }

      .input-area {
        padding: 25px;
        background: white;
        border-top: 1px solid #e9ecef;
      }

      .input-group {
        display: flex;
        gap: 12px;
        align-items: center;
      }

      #messageInput {
        flex: 1;
        padding: 15px 20px;
        border: 2px solid #e9ecef;
        border-radius: 25px;
        font-size: 16px;
        outline: none;
        transition: border-color 0.3s ease;
      }

      #messageInput:focus {
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      }

      #sendButton {
        padding: 15px 30px;
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        border: none;
        border-radius: 25px;
        cursor: pointer;
        font-weight: bold;
        font-size: 16px;
        transition: transform 0.2s ease;
      }

      #sendButton:hover {
        transform: translateY(-2px);
      }
      #sendButton:disabled {
        background: #6c757d;
        cursor: not-allowed;
        transform: none;
      }

      .controls {
        display: flex;
        gap: 12px;
        margin-top: 15px;
        flex-wrap: wrap;
      }

      .btn-secondary {
        padding: 10px 20px;
        background: #6c757d;
        color: white;
        border: none;
        border-radius: 20px;
        cursor: pointer;
        font-size: 14px;
        transition: background 0.2s ease;
      }

      .btn-secondary:hover {
        background: #545b62;
      }

      .message {
        margin: 20px 0;
        padding: 15px 20px;
        border-radius: 20px;
        max-width: 85%;
        word-wrap: break-word;
        animation: slideIn 0.4s ease;
        position: relative;
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateY(15px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.7;
        }
      }

      .user {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        margin-left: auto;
        text-align: right;
      }

      .assistant {
        background: white;
        border: 2px solid #e9ecef;
        color: #333;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
      }

      .system {
        background: linear-gradient(135deg, #ffeaa7, #fdcb6e);
        color: #2d3436;
        text-align: center;
        margin: 15px auto;
        max-width: 90%;
        font-weight: 500;
      }

      .typing {
        background: #e9ecef;
        color: #6c757d;
        font-style: italic;
        animation: pulse 1.5s ease-in-out infinite;
      }

      .streaming {
        background: linear-gradient(135deg, #74b9ff, #0984e3);
        color: white;
        position: relative;
        overflow: hidden;
      }

      .streaming::after {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(255, 255, 255, 0.2),
          transparent
        );
        animation: shimmer 2s infinite;
      }

      @keyframes shimmer {
        0% {
          left: -100%;
        }
        100% {
          left: 100%;
        }
      }

      .transcription {
        background: #e8f4fd;
        color: #0c5460;
        border-left: 4px solid #17a2b8;
        font-style: italic;
      }

      @media (max-width: 768px) {
        .main-content {
          flex-direction: column;
          height: auto;
        }

        .voice-panel {
          width: 100%;
          order: -1;
        }

        #chatContainer {
          height: 400px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>ğŸ¤ UMate AI Assistant</h1>
        <p>ìŒì„± + í…ìŠ¤íŠ¸ ë©€í‹°ëª¨ë‹¬ ëŒ€í™”</p>
        <div class="features">
          âœ¨ ì‹¤ì‹œê°„ ìŒì„± ì¸ì‹ â€¢ ğŸ”Š AI ìŒì„± ë‹µë³€ â€¢ ğŸ’¬ í…ìŠ¤íŠ¸ ë™ì‹œ ì§€ì› â€¢ âš¡
          ì´ˆê³ ì† ì‘ë‹µ
        </div>
      </div>

      <div id="status" class="status-connecting">ì—°ê²° ì¤‘...</div>

      <div class="main-content">
        <div id="chatContainer"></div>

        <div class="voice-panel">
          <div class="voice-controls">
            <h3>ğŸ¤ ìŒì„± ì œì–´</h3>
            <button id="recordButton" class="record-idle">
              ìŒì„±ìœ¼ë¡œ ì§ˆë¬¸í•˜ê¸°
            </button>

            <div class="voice-selector">
              <label for="voiceSelect">AI ìŒì„± ì„ íƒ:</label>
              <select id="voiceSelect">
                <option value="alloy">Alloy (ê¸°ë³¸)</option>
                <option value="echo">Echo</option>
                <option value="fable">Fable</option>
                <option value="onyx">Onyx</option>
                <option value="nova">Nova</option>
                <option value="shimmer">Shimmer</option>
              </select>
            </div>
          </div>

          <div class="voice-controls">
            <h3>ğŸ“Š ìƒíƒœ</h3>
            <div id="micStatus">ğŸ¤ ë§ˆì´í¬ ëŒ€ê¸° ì¤‘</div>
            <div id="audioStatus">ğŸ”Š ìŠ¤í”¼ì»¤ ì¤€ë¹„ë¨</div>
          </div>
        </div>
      </div>

      <div class="input-area">
        <div class="input-group">
          <input
            type="text"
            id="messageInput"
            placeholder="í…ìŠ¤íŠ¸ë¡œ ë©”ì‹œì§€ë¥¼ ì…ë ¥í•˜ê±°ë‚˜ ìŒì„± ë²„íŠ¼ì„ ì‚¬ìš©í•˜ì„¸ìš”..."
            disabled
          />
          <button id="sendButton" disabled>ì „ì†¡</button>
        </div>
        <div class="controls">
          <button class="btn-secondary" onclick="clearChat()">
            ëŒ€í™” ì´ˆê¸°í™”
          </button>
          <button class="btn-secondary" onclick="reconnect()">ì¬ì—°ê²°</button>
          <button class="btn-secondary" onclick="testAudio()">
            ì˜¤ë””ì˜¤ í…ŒìŠ¤íŠ¸
          </button>
        </div>
      </div>
    </div>

    <script>
      const chatContainer = document.getElementById("chatContainer");
      const messageInput = document.getElementById("messageInput");
      const sendButton = document.getElementById("sendButton");
      const status = document.getElementById("status");
      const recordButton = document.getElementById("recordButton");
      const voiceSelect = document.getElementById("voiceSelect");
      const micStatus = document.getElementById("micStatus");
      const audioStatus = document.getElementById("audioStatus");

      const sessionId = "realtime_" + Date.now();
      let ws;
      let currentStreamingMessage = null;
      let streamingText = "";
      let audioContext;
      let mediaRecorder;
      let audioChunks = [];
      let isRecording = false;
      let isConnected = false;

      // ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸ ì´ˆê¸°í™”
      async function initAudio() {
        try {
          audioContext = new (window.AudioContext || window.webkitAudioContext)(
            { sampleRate: 16000 }
          );
          audioStatus.textContent = "ğŸ”Š ì˜¤ë””ì˜¤ ì¤€ë¹„ë¨";
          return true;
        } catch (error) {
          console.error("ì˜¤ë””ì˜¤ ì´ˆê¸°í™” ì˜¤ë¥˜:", error);
          audioStatus.textContent = "âŒ ì˜¤ë””ì˜¤ ì˜¤ë¥˜";
          return false;
        }
      }

      // ë§ˆì´í¬ ê¶Œí•œ ìš”ì²­
      async function requestMicPermission() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            audio: {
              sampleRate: 16000,
              channelCount: 1,
              echoCancellation: true,
              noiseSuppression: true,
            },
          });

          mediaRecorder = new MediaRecorder(stream);
          micStatus.textContent = "ğŸ¤ ë§ˆì´í¬ ì¤€ë¹„ë¨";

          mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
              audioChunks.push(event.data);
            }
          };

          mediaRecorder.onstop = async () => {
            const audioBlob = new Blob(audioChunks, { type: "audio/wav" });
            const arrayBuffer = await audioBlob.arrayBuffer();
            const audioData = await audioContext.decodeAudioData(arrayBuffer);

            // PCM16 ë³€í™˜
            const pcm16 = convertToPCM16(audioData);
            const base64Audio = arrayBufferToBase64(pcm16);

            // ìŒì„± ë°ì´í„° ì „ì†¡
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(
                JSON.stringify({
                  type: "audio_data",
                  audio: base64Audio,
                })
              );

              setTimeout(() => {
                ws.send(
                  JSON.stringify({
                    type: "audio_commit",
                  })
                );
              }, 100);
            }

            audioChunks = [];
          };

          return true;
        } catch (error) {
          console.error("ë§ˆì´í¬ ê¶Œí•œ ì˜¤ë¥˜:", error);
          micStatus.textContent = "âŒ ë§ˆì´í¬ ì ‘ê·¼ ë¶ˆê°€";
          alert(
            "ë§ˆì´í¬ ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤. ë¸Œë¼ìš°ì € ì„¤ì •ì—ì„œ ë§ˆì´í¬ ê¶Œí•œì„ í—ˆìš©í•´ì£¼ì„¸ìš”."
          );
          return false;
        }
      }

      // PCM16 ë³€í™˜ í•¨ìˆ˜
      function convertToPCM16(audioBuffer) {
        const inputData = audioBuffer.getChannelData(0);
        const outputData = new Int16Array(inputData.length);

        for (let i = 0; i < inputData.length; i++) {
          const sample = Math.max(-1, Math.min(1, inputData[i]));
          outputData[i] = sample < 0 ? sample * 0x8000 : sample * 0x7fff;
        }

        return outputData.buffer;
      }

      // ArrayBufferë¥¼ Base64ë¡œ ë³€í™˜
      function arrayBufferToBase64(buffer) {
        const bytes = new Uint8Array(buffer);
        let binary = "";
        for (let i = 0; i < bytes.byteLength; i++) {
          binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary);
      }

      // Base64ë¥¼ ArrayBufferë¡œ ë³€í™˜
      function base64ToArrayBuffer(base64) {
        const binaryString = atob(base64);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes.buffer;
      }

      // ìŒì„± ì¬ìƒ
      async function playAudio(base64Audio) {
        try {
          const arrayBuffer = base64ToArrayBuffer(base64Audio);
          const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
          const source = audioContext.createBufferSource();
          source.buffer = audioBuffer;
          source.connect(audioContext.destination);
          source.start();
          audioStatus.textContent = "ğŸ”Š ìŒì„± ì¬ìƒ ì¤‘...";

          source.onended = () => {
            audioStatus.textContent = "ğŸ”Š ìŒì„± ì¬ìƒ ì™„ë£Œ";
          };
        } catch (error) {
          console.error("ìŒì„± ì¬ìƒ ì˜¤ë¥˜:", error);
          audioStatus.textContent = "âŒ ì¬ìƒ ì˜¤ë¥˜";
        }
      }

      // ìƒíƒœ ì—…ë°ì´íŠ¸
      function updateStatus(text, className) {
        status.textContent = text;
        status.className = className;
      }

      // WebSocket ì—°ê²°
      function connect() {
        updateStatus("ì—°ê²° ì¤‘...", "status-connecting");
        ws = new WebSocket(
          `ws://localhost:3002/ws/realtime-chat?sessionId=${sessionId}`
        );

        ws.onopen = () => {
          console.log("WebSocket ì—°ê²°ë¨");
        };

        ws.onmessage = async (event) => {
          const data = JSON.parse(event.data);

          switch (data.type) {
            case "connection":
              if (data.status === "connected") {
                updateStatus("âœ… ìŒì„±+í…ìŠ¤íŠ¸ ì±„íŒ… ì¤€ë¹„ë¨", "status-connected");
                messageInput.disabled = false;
                sendButton.disabled = false;
                recordButton.disabled = false;
                isConnected = true;
                addMessage(data.message, "system");

                // ì˜¤ë””ì˜¤ ì´ˆê¸°í™”
                await initAudio();
                await requestMicPermission();
              } else {
                updateStatus("âŒ ì—°ê²° ëŠê¹€", "status-error");
                messageInput.disabled = true;
                sendButton.disabled = true;
                recordButton.disabled = true;
                isConnected = false;
              }
              break;

            case "speech_started":
              updateStatus("ğŸ¤ ìŒì„± ì¸ì‹ ì¤‘...", "status-recording");
              break;

            case "speech_stopped":
              updateStatus("ğŸ”„ ìŒì„± ì²˜ë¦¬ ì¤‘...", "status-connecting");
              break;

            case "transcription_complete":
              addMessage('ğŸ¤ "' + data.transcription + '"', "transcription");
              break;

            case "assistant_message_start":
              if (currentStreamingMessage) {
                currentStreamingMessage.remove();
              }
              streamingText = "";
              currentStreamingMessage = addMessage(
                "ë‹µë³€ì„ ìƒì„±í•˜ê³  ìˆìŠµë‹ˆë‹¤...",
                "typing"
              );
              break;

            case "text_delta":
              streamingText += data.delta;
              if (currentStreamingMessage) {
                if (currentStreamingMessage.classList.contains("typing")) {
                  currentStreamingMessage.remove();
                  currentStreamingMessage = addMessage("", "streaming");
                }
                currentStreamingMessage.textContent = streamingText;
              }
              break;

            case "audio_delta":
              // ì‹¤ì‹œê°„ ìŒì„± ì¬ìƒ
              if (data.audio) {
                await playAudio(data.audio);
              }
              break;

            case "audio_transcript_delta":
              // ìŒì„± ì‘ë‹µì˜ í…ìŠ¤íŠ¸ ë²„ì „
              streamingText += data.delta;
              if (currentStreamingMessage) {
                if (currentStreamingMessage.classList.contains("typing")) {
                  currentStreamingMessage.remove();
                  currentStreamingMessage = addMessage("", "streaming");
                }
                currentStreamingMessage.textContent = streamingText;
              }
              break;

            case "text_done":
            case "audio_transcript_done":
              if (currentStreamingMessage) {
                currentStreamingMessage.className = "message assistant";
                currentStreamingMessage.textContent =
                  data.text || data.transcript;
              }
              break;

            case "response_complete":
              if (currentStreamingMessage) {
                currentStreamingMessage.className = "message assistant";
              }
              currentStreamingMessage = null;
              streamingText = "";
              sendButton.disabled = false;
              recordButton.disabled = false;
              updateStatus("âœ… ì‘ë‹µ ì™„ë£Œ", "status-connected");
              break;

            case "error":
              addMessage("âŒ ì˜¤ë¥˜: " + data.error, "system");
              sendButton.disabled = false;
              recordButton.disabled = false;
              if (currentStreamingMessage) {
                currentStreamingMessage.remove();
                currentStreamingMessage = null;
              }
              break;
          }
        };

        ws.onclose = () => {
          updateStatus("âŒ ì—°ê²° ëŠê¹€ - ì¬ì—°ê²° ì‹œë„ ì¤‘...", "status-error");
          messageInput.disabled = true;
          sendButton.disabled = true;
          recordButton.disabled = true;
          isConnected = false;

          setTimeout(connect, 3000);
        };

        ws.onerror = (error) => {
          console.error("WebSocket ì˜¤ë¥˜:", error);
          updateStatus("âŒ ì—°ê²° ì˜¤ë¥˜", "status-error");
        };
      }

      // ë©”ì‹œì§€ ì¶”ê°€
      function addMessage(content, role) {
        const messageDiv = document.createElement("div");
        messageDiv.className = "message " + role;
        messageDiv.textContent = content;
        chatContainer.appendChild(messageDiv);
        chatContainer.scrollTop = chatContainer.scrollHeight;
        return messageDiv;
      }

      // í…ìŠ¤íŠ¸ ë©”ì‹œì§€ ì „ì†¡
      function sendMessage() {
        const message = messageInput.value.trim();
        if (!message || !ws || ws.readyState !== WebSocket.OPEN) return;

        addMessage(message, "user");
        messageInput.value = "";
        sendButton.disabled = true;

        ws.send(
          JSON.stringify({
            type: "user_message",
            message: message,
          })
        );
      }

      // ìŒì„± ë…¹ìŒ í† ê¸€
      function toggleRecording() {
        if (!isConnected || !mediaRecorder) return;

        if (!isRecording) {
          // ë…¹ìŒ ì‹œì‘
          mediaRecorder.start();
          isRecording = true;
          recordButton.textContent = "ğŸ›‘ ë…¹ìŒ ì¤‘... (í´ë¦­í•´ì„œ ì¤‘ë‹¨)";
          recordButton.className = "record-active";
          updateStatus("ğŸ¤ ìŒì„± ë…¹ìŒ ì¤‘...", "status-recording");
          micStatus.textContent = "ğŸ”´ ë…¹ìŒ ì¤‘...";
        } else {
          // ë…¹ìŒ ì¤‘ë‹¨
          mediaRecorder.stop();
          isRecording = false;
          recordButton.textContent = "ì²˜ë¦¬ ì¤‘...";
          recordButton.className = "record-processing";
          recordButton.disabled = true;
          updateStatus("ğŸ”„ ìŒì„± ì²˜ë¦¬ ì¤‘...", "status-connecting");
          micStatus.textContent = "ğŸ”„ ì²˜ë¦¬ ì¤‘...";

          setTimeout(() => {
            recordButton.textContent = "ìŒì„±ìœ¼ë¡œ ì§ˆë¬¸í•˜ê¸°";
            recordButton.className = "record-idle";
            recordButton.disabled = false;
            micStatus.textContent = "ğŸ¤ ë§ˆì´í¬ ì¤€ë¹„ë¨";
          }, 1000);
        }
      }

      // ìŒì„± ë³€ê²½
      function changeVoice() {
        const voice = voiceSelect.value;
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(
            JSON.stringify({
              type: "voice_change",
              voice: voice,
            })
          );
        }
      }

      // ëŒ€í™” ì´ˆê¸°í™”
      function clearChat() {
        if (confirm("ëŒ€í™”ë¥¼ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) {
          chatContainer.innerHTML = "";
          addMessage("ëŒ€í™”ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.", "system");
        }
      }

      // ì¬ì—°ê²°
      function reconnect() {
        if (ws) {
          ws.close();
        }
        connect();
      }

      // ì˜¤ë””ì˜¤ í…ŒìŠ¤íŠ¸
      function testAudio() {
        if (audioContext) {
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();

          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);

          oscillator.frequency.value = 440;
          gainNode.gain.value = 0.1;

          oscillator.start();
          oscillator.stop(audioContext.currentTime + 0.2);

          audioStatus.textContent = "ğŸ”Š í…ŒìŠ¤íŠ¸ ì™„ë£Œ";
        }
      }

      // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
      sendButton.addEventListener("click", sendMessage);
      recordButton.addEventListener("click", toggleRecording);
      voiceSelect.addEventListener("change", changeVoice);

      messageInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter" && !sendButton.disabled) {
          sendMessage();
        }
      });

      // í˜ì´ì§€ ë¡œë“œ ì‹œ ì—°ê²° ì‹œì‘
      connect();
    </script>
  </body>
</html>
